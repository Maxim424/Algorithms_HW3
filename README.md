# Algorithms_HW3
Исследование алгоритмов поиска кратчайшего пути

Кузнецов Максим Вадимович. БПИ219

## Основная информация
Код находится в папке `Algorithms_HW3`. Реализованы по критериям 3 алгоритма:
- Дейкстры (хранение в priority_queue)
- Флойда-Уоршела
- Форда-Баллмана
- Дейкстры (хранение в массиве), на доп. балл

Все функции, реализующие алгоритмы, находятся в папке `algorithms` и передаются с помощью указателя в функцию `execute`, находящуюся в папке `utilities`.

Все алгоритмы были взяты из решений контеста №14 и лекций, а затем доработаны так, чтобы в каждом алгоритме граф был представлен в виде списка смежности типа std::vector<std::vector<Edge>>.

Получившиеся таблицы (.csv и numbers) и графики (.pdf) находятся в папке `tables`. Например, графики для алгоритма Дейкстры можно найти в файле `tables/dijkstra.pdf`. Аргегированные графики находятся в файле `tables/aggregate charts/aggregate charts.pdf`.
  
Каждое значение в таблице получено путем усреднения 3 замеров времени работы того или иного алгоритма. Некоторые графики имеют логарифмическую ось Y, чтобы кривые на них не сливались с осью X.
  
## Вывод
На всех агрегированных графиках видно, что алгоритм Флойда-Уоршела работает значительно медленнее по сравнению с остальными алгоритмами. Это можно объяснить тем, что его асимптотика – O(n^3). К тому же, несмотря на усреднение замеров времени, в таблице для алгоритма Флойда-Уоршела есть выбросы (на полном графе при 760 вершинах).
  
Интересно, что на полном графе обычно рекомендуется использовать алгоритм Флойда-Уоршела, но, как указано выше, он во всех случаях работает медленнее остальных алгоритмов. Также этот алгоритм работает примерно одинаково на всех представленных видах графов, в то время как, например, Форд-Беллман работает на деревьях значительно быстрее, чем на полных и связных графах.
  
Если граф разреженный, то согласно графикам лучше всего использовать алгоритм Форда-Беллмана. Его асимптотика – O(n*m), но при улучшенной реализации (для которой и производились замеры) в среднем этот алгоритм работает значительно лучше остальных.
  
Дейкстра на базе массиве работал во всех случаях хуже, чем Дейкстра на базе priority_queue, поэтому использовать первый вариант практически не имеет смысла, особенно на разреженном графе, где асимптотика c priority_queue – O(n*logn) вместо O(n^2).
